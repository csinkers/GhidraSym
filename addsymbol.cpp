// Adds Ghidra symbols as WinDbg synthetic symbols
//
// Adapted from https://gist.github.com/ikonst/ebae548dac7934dc0bdf
// Original code by 'blabb'.
// 
// See:
// http://www.woodmann.com/forum/entry.php?262-addsym-windbg-extension-%28extension-to-load-names-from-ida-to-windbg%29
// http://reverseengineering.stackexchange.com/questions/3850/importing-list-of-functions-and-addresses-into-windbg

#include <fstream>
#include <string>
#include <tchar.h>
#include <vector>
#include "engexpcpp.hpp"
#include <sstream>

EXT_API_VERSION g_ExtApiVersion = {
	 5 ,
	 5 ,
	 EXT_API_VERSION_NUMBER ,
	 0
 } ;

LPEXT_API_VERSION WDBGAPI ExtensionApiVersion (void)
{
    return &g_ExtApiVersion;
}

VOID WDBGAPI WinDbgExtensionDllInit (PWINDBG_EXTENSION_APIS 
           lpExtensionApis, USHORT usMajorVersion, 
           USHORT usMinorVersion)
{
     ExtensionApis = *lpExtensionApis;
}

class EXT_CLASS : public ExtExtension
{
public:
	EXT_CLASS() {}
	EXT_COMMAND_METHOD(addsym);
};

EXT_DECLARE_GLOBALS();


// takes two arguments first is an expression second is a string (path of symbol file)
// !addsym modulename filename 
// e.g. !addsym SomeModuleName C:\tmp\something.exe.xml
// e.g. !addsym 00400000 C:\tmp\something.exe.xml

struct SymbolDef
{
	std::string name;
	uint64_t offset;
	uint64_t size;
};

bool has_prefix(const char **start, const char* prefix)
{
	if (start == nullptr || *start == nullptr)
		return false;

	const char* s = *start;
	for (; *s != 0 && (*s == ' ' || *s == '\t'); s++) {} // Skip whitespace
	for (; *s != 0 && *prefix != 0 && *s == *prefix; s++, prefix++) {} // Skip prefix
	if (*prefix) // Prefix didn't match
		return false;

	*start = s; // Update start pointer if prefix was found
	return true;
}

void parse_line(const char* line, std::vector<SymbolDef>& symbols, uint64_t &module_offset)
{
    // Quick and dirty parsing.
	static bool in_functions = false;
	const char* s = line;

    if(module_offset == 0 && has_prefix(&s, "<PROGRAM NAME=\""))
    {
        // <PROGRAM NAME="test.exe" EXE_PATH="C:/Tmp/ReversingTest/test.exe" EXE_FORMAT="Portable Executable (PE)" IMAGE_BASE="00400000">
        const char *prefix = "IMAGE_BASE=\"";
        for (; *s != 0 && *prefix != 0; ++s)
            if (*s == *prefix)
                ++prefix;

        if (*prefix == 0)
            module_offset = strtoull(s, nullptr, 16);
    }
    else if (has_prefix(&s, "<FUNCTIONS"))
	{
		in_functions = (*s != '/');
	}
	else if (in_functions && has_prefix(&s, "<FUNCTION ENTRY_POINT=\""))
	{
        /*
        <FUNCTION ENTRY_POINT="00401005" NAME="gets_s" LIBRARY_FUNCTION="n">
            <ADDRESS_RANGE START="00401005" END="00401009" />
            <TYPEINFO_CMT>undefined __cdecl gets_s(char * buffer)</TYPEINFO_CMT>
            <STACK_FRAME LOCAL_VAR_SIZE="0xc8" PARAM_OFFSET="0x4" RETURN_ADDR_SIZE="0x0" BYTES_PURGED="0">
                <STACK_VAR STACK_PTR_OFFSET="-0xc4" NAME="local_c4" DATATYPE="undefined1" DATATYPE_NAMESPACE="/" SIZE="0x1" />
                <STACK_VAR STACK_PTR_OFFSET="0x4" NAME="buffer" DATATYPE="char *" DATATYPE_NAMESPACE="/" SIZE="0x4" />
            </STACK_FRAME>
        </FUNCTION>
        */
		const uint64_t offset = strtoull(s, nullptr, 16);

		const char *prefix = "\" NAME=\"";
		for (; *s != 0 && *prefix != 0; s++) { if (*s == *prefix) prefix++; }

		if (*prefix == 0)
		{
			std::stringstream os;
			for (; *s != 0 && *s != '"'; s++) { os << *s; }
			symbols.push_back({ os.str(), offset-module_offset, 4 });
		}
	}
	else if (in_functions && has_prefix(&s, "<ADDRESS_RANGE START=\""))
	{
		const uint64_t offset = strtoull(s, nullptr, 16);
		const char *prefix = "\" END=\"";
		for (; *s != 0 && *prefix != 0; s++) { if (*s == *prefix) prefix++; }
		const uint64_t end_offset = strtoull(s, nullptr, 16);
		symbols.back().offset = offset - module_offset;
		symbols.back().size = end_offset - offset;
	}
}

EXT_COMMAND(
	addsym,
	"windbg extension to use names that are generated by ghidra \n do .reload /f MODULE.ext=base,size prior to using this extension",
	"{;e;MODULE;An expression or address like nt / 0x804d7000 }{;x;path;path to ghidra XML export file c:\\tmp\\MODULE.EXE.xml}"
)
{
	std::ifstream fs;
	std::string inbuff, buff;
	const ULONG64 imagebase = GetUnnamedArgU64(0);

	fs.open(GetUnnamedArgStr(1));

	if ((fs.rdstate() & std::ifstream::failbit) != 0)
	{
		Out("failed to open idasym file\n");
		return;
	}

	Out("Parsing symbols");
	{
		uint64_t offset = 0;
		std::vector<SymbolDef> symbols;
		int i = 0;
		while (getline(fs, buff))
		{
			if (m_Control3->GetInterrupt() == S_OK) break;
            parse_line(buff.c_str(), symbols, offset);
			if (++i % 500 == 0) Out(".");
		}
		fs.close();

		Out("\n%d symbols parsed\n", symbols.size());
		Out("Registering symbols");

		i = 0;
		for (auto it = symbols.begin(); it != symbols.end(); ++it)
		{
			m_Symbols3->AddSyntheticSymbol((imagebase + it->offset), it->size, it->name.c_str(), DEBUG_ADDSYNTHSYM_DEFAULT, nullptr);
			if (++i % 500 == 0) Out(".");
		}
		Out("\nSymbols registered\n", i);
	}
}

